# sat-polynomial-time-solver
Adding my algorithm here soon.
So far, I'm having trouble writing the algorithm in code, so I'll add the steps of my algorithm here to ensure how it works:
1. First, we sort the arrays by length, sort the elements from the arrays from low to high and dedupe any arrays that mean the same. So for example, we have arrays like [1 2] and [2 1]. They mean the same thing, so only one will remain like [1 2]. If we have [1 1 2], it will get deduped to [1 2] because the same element gets repeated. If you have arrays that have elements like [1 -1 2], the array gets skipped entirely.
2. Next, we find the highest number in all of the arrays. This highest number will be represented by the integer "n". So if you have a series of arrays [1],[1 2],[1 2 3], 3 is the highest number so n = 3.
3. We iterate through the arrays and we count the number of positive and negative instances of each element. Say we take the sample arrays:
   [5]
   [-1 2]
   [1 -2]
   [1 2]
   [3 -4 5]
   [-1 -2 -3 -4 -5]
   [1 2 3 4 5]
   We go through the first array which has the element 5. We check the length of the array first which is 1, therefore we take a variable k that represents the length of the current array, which in our case is equal to 1 so k = 1. Now we go through the elements of the array. Here, 5 represents a variable x5 which represents the values [0,1]. We check to see if it's positive or negative, since it's 5 and not -5, we take the count of positive x5s which starts at 0. If the count starts at 0, this will be equal to 2^(n-k) which for our case is 2^(5-1) = 2^(4) = 16. So the count of positive x5s is equal to 16. We check if this is equal to 2^(n-1), which for the list of the arrays in this example is 5 so 2^(5-1) = 16. Therefore it's the same. The count of positive x5s is equal to 2^(n-1), which means that x5 will go from the initial values of [0,1] to 1, so x5 -> 1. If it were the negative count, x5 would have been 0. Moving on to the next array. We have [-1 2], k will be equal to 2. We have a negative 1, which we take the count of negative x1s which is 0 by default. It turns to 2^(n-k) = 2^(5-2) = 2^3 = 8. We check if it's equal to 2^(n-1) afterwards, it's not this time. We move on to the next element and so on. We do the same for 2, 2 in this case is positive therefore we take the count of positive x2s, which is 0 and we do the same steps, so it will also turn into 2^(n-k). Move on to the next array, [1 -2]. Doing the same steps from before, we will have a count of positive x1s and negative x2s as equal to 2^(n-k). Move on to the next, we have [1 2]. This time, the counts for each don't start with 0 by default, they start with 8 each since the counts are global. This time, it's different from 0, so we check to see if the modulo to 2^(n-k) is equal to 0. In our case it is, therefore, the count gets added with 2^(n-k) which is 2^(3) = 8, so 8+8 = 16. We check to see if it's equal to 2^(n-1). It is, so therefore x1 will turn to 1. Same thing happens for x2. Doing the same steps, we see that x2 will turn from [0,1] to 1. Do the same thing for every single element afterwards and take the counts for each positive and negative instances respectively. After you did all of that, you need to check for satisfiability. The way you do that is that the formula will be unsatisfiable if the count of both positive and negative instances of the same integer are equal to each other AND are equal to 2^(n-1). If none meet the criteria, then the formula is satisfiable. If they do, you need to break the program and output "This formula is unsatisfiable". To check which values from [0,1] from the remaining variables meet the criteria, we iterate through the array again but this time, we start from a variable that has already a value declared, so for our case, either x1 ->1, x2 -> 1 or x5 -> 1. The choice can be random, so for our case, we'll choose x5 and iterate through the entire list of arrays starting from that element. Now, each array must hold TRUE, a.k.a. there must exist at least one "1" in the array of variables. We iterate. First is [5]. x5 is 1 so it holds true. Move on. Next is [-1 2], x1 -> 1 and x2 -> 1 so the values have already been declared. Move on. [1 -2], result's the same, [1 2], result's also the same. [3 -4 5]. We check, we have x5 in the array which is 1, so that means that x3 and x4 will remain the same with the values [0,1]. Therefore you can choose a value arbitrarily, so x3 can be 0, x4 can be 0 and x5 can be 1. Or x3 can be 1, x4 can be 0 and x5 is 1, or x3 -> 0, x4 -> 1, x5 -> 1. Or x3 -> 1, x4 -> 1, x5 -> 1, but if you do this, you will need to take note of the next array. [-1 -2 -3 -4 -5]. If we take the case I mentioned, you would have x1 -> 0, x2 -> 0, x3 -> 0, x4 -> 0 and x5 -> 0 because the minus reverses the value, so they turn from 1 to 0, and because every value in that array is 0, we need to change either the value of x3 or x4, because they were both initially [0,1], and they didn't have the variable changed to a single number, like x1, x2 or x3. One of either x4 or x5 must be equal to 1 to satisfy the condition. So the outputs will be:
This formula is satisfiable.
x1 -> 1      x1 -> 1      x1 -> 1
x2 -> 1      x2 -> 1      x2 -> 1
x3 -> 0  or  x3 -> 0  or  x3 -> 1 
x4 -> 0      x4 -> 1      x4 -> 0
x5 -> 1      x5 -> 1      x5 -> 1
x3 and x4 will depend on the clauses, but these are the possible outputs for our case.
P.S. I forgot to add a step which is related to the counting process. The initial step needs to check if the count is bigger than 2^(n-k). If it is, the element gets skipped and it moves on to the next.
