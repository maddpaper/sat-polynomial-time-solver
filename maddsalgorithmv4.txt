Alright, let's say that we have an input file with arrays. For example:
  [1 2 3 4 5]
  [-1 -2 -3 -4 -5]
  [1 -2]
  [3 -4 5]
  [5]
  [-1 2]
  [1 -1 2]
First, dedupe any arrays in this way: If you have arrays like [1 2] and [2 1], eliminate one of them and one shall remain, like [1 2]. If you have [1 1 2], you dedupe it to [1 2] because it means the same thing. If you have an array like [1 -1 2], you remove the entire array because you have both the positive and negative value of the same integer which is 1.
Now, find the highest element in all the arrays and put it in an integer called "n". So for our example, we see that the highest number is 5, therefore we put n = 5.
Now, here's the actual part that you need to do. Think of the numbers in the arrays as variables. 1 represents x1, 2 represents x2, 3 represents x3 and so on. You need to assign values of 0 or 1 to each variable based on certain conditions. Do these steps:
First, for each variable, there's a count of their positive and negative instances. So you have a count of the positive instances of x1, like count_pos_x1, a count of the negative instances of x1, like count_neg_x1, a count of the positive instances of x2, like count_pos_x2, a count of negative instances of x2 like count_neg_x2 and so on. The positivity and negativity count is determined when you check if the element you're currently on is either positive or negative. For example, if 1 is positive, then the count of positive x1s will be affected. If it's negative, the count of negative x1s will be affected. Now, each count for their variable, both positive and negative, starts with 2^(n-1), which in our case is n = 5, therefore 2^(5-1) = 2^(4) = 16. So we have:

count_pos_x1 = 16
count_pos_x2 = 16
count_pos_x3 = 16
count_pos_x4 = 16
count_pos_x5 = 16
count_neg_x1 = 16
count_neg_x2 = 16
count_neg_x3 = 16
count_neg_x4 = 16
count_neg_x5 = 16

Next, compare each array in part and do as follows. First array is [1 2 3 4 5]. What we want to check for this array is the arrays that have any common elements between them. Or rather, if we can find arrays that have everything in common. We check it first with [-1 -2 -3 -4 -5]. We see that we don't actually have any common elements with any of them. [1 2 3 4 5] has no common elements with [-1 -2 -3 -4 -5] and not all of them are common. We go to the next array and compare them. Next is [1 -2]. Compare the arrays [1 2 3 4 5] and [1 -2]. We see that we have one common element in those arrays, which is 1. However, -2 is not common with the other array. So we don't have every single element in the array as common. Therefore we skip and move on to the next array, which is [3 -4 5]. We see that the common elements between each other are 3 and 5. However, -4 is not common with the array, therefore the array shall be skipped and we move on to the next array, which is 5. This time, we see that we have all the elements between the arrays are common, because [5] is included in [1 2 3 4 5]. Therefore, the array [1 2 3 4 5] shall be deleted, along with its counts and we go with the next array, which is [-1 -2 -3 -4 -5]. You don't check any array that came before it because those arrays have already been checked, so instead you check with the next arrays, not the previous ones. We check the arrays and we check it with every single element in the array, however, if you proceed with the previous steps mentioned before, you will find that the array [-1 -2 -3 -4 -5] won't have any arrays that will have every single element in common with each other, therefore it remains and we move on with the next, which is [1 -2]. We check it with every single array, but as mentioned before, it won't have any arrays that will have every single element in common with each other, so it shall remain. Next is [3 -4 5]. We compare it with the arrays, but as you can see, this time, we find the right arrays, which is [5]. So we have [3 -4 5] and [5]. All elements are common between each other, therefore [3 -4 5] gets deleted along with its counts. Here's a quick note. If you ever found yourself comparing [5] with [3 -4 5], you deleted the one that had more elements in it, which is [3 -4 5]. You always delete the bigger array between each other. So then [5] will remain. Next is [-1 2], but also this time, you won't find anything. Therefore, the remaining arrays are:

[-1 -2 -3 -4 -5]
[1 -2]
[5]
[-1 2]

Next, sort the arrays by length from lowest to highest, such as:
[5]
[1 -2]
[-1 2]
[-1 -2 -3 -4 -5]

Check each array in part and subtract their counts as follows. First, we have the array [5]. But first, check if there are any missing variables. We see that 1, 2, 3, 4 are missing from the array. We check if any of their counts are equal to 0. So far, none of them are equal to 0, so we take a variable l which represents the number of declared variables. l starts with 1 first, not 0. so l = 1. We move on with our array. First, we see that 5 is positive, therefore we subtract the count of positive x5s with (2^(n-k))/l, with k being the length of the array. So 2^(5-1)/1 = 2^(4)/1 = 16/1 = 16. Therefore the count of positive x5s will be 16 - 16 = 0. Next, we check if there are missing elements in the array. As we can see, the missing elements are 1,2,3 and 4. For the missing elements in the array, we subtract their respective negative AND positive count of each variable with 2^(n-k-1)/l, so 2^(5-1-1)/1 = 2^3/1 = 8/1 = 8. So we would have count_pos_x1, count_neg_x1, count_pos_x2, count_neg_x2, count_pos_x3, count_neg_x3, count_pos_x4 and count_neg_x4 all equal to 16 - 2^(3) = 16 - 8 = 8. We move on to the next array, which is [1 -2]. We check the length of the array, which is 2. So k = 2. Now, this time, check if there are any missing variables. We see that 3, 4 and 5 are missing from the array. Check if any of their counts are equal to 0. This time, we have count_pos_x5 = 0. Therefore, we have l = 2 (NOTE: If you had 2 variables that had their counts equal to 0, for example, count_pos_x4 = 0 and count_pos_x5 = 0, then l would be equal to 3, because we would have 2 variables which have their count as equal to 0. It would be l = 1 + 2 = 3. Also remember that the integer l is not a global variable and it only takes into account the current array, l resets to 1 when it moves on to the next array. But anyways, for our case, it's not l = 3 but l = 2. Let's move on with the array). Check each variable in part and subtract their counts respectively. We have 1, so we take the count of positive x1s and subtract it again with (2^(n-k))/l, so 2^(5-2)/2 = 2^(3)/2 = 8/2 = 4, so count_pos_x1 will be 8 - 4 = 4. Check the next element, it's -2. We see that it's negative, therefore we subtract the count of negative x2s with 2^(n-k)/l, so count_neg_x2 = 8 - 4 = 4. Now, we check if there are any missing elements. We 3, 4 and 5 as missing. Therefore we take their respective negative and positive count of each variable and subtract 2^(n-k-1)/l, so 2^(5-2-1)/2 = 2^2/2 = 4/2 = 2. Here's a quick note before you do anything. If you have any of these counts as equal to 0, you do not subtract that count because the count is already null. Like for example, count_pos_x5 = 0. You do not subtract it with 2^(n-k-1)/l because it's already 0. Anyways, let's move on. If you do the steps as I mentioned, you would have count_pos_x3, count_neg_x3, count_pos_x4, count_neg_x4 all equal to 8 - 2 = 6, with count_pos_x5 = 0 and count_neg_x5 = 16 - 2 = 14. Now, we move on to the next array, which is [-1 2]. Do the exact same steps as I've mentioned before. It will turn out that you will have count_neg_x1 = 4, count_pos_x2 = 4, count_pos_x3 = 4, count_neg_x3 = 4, count_pos_x4 = 4, count_neg_x4 = 4 and count_pos_x5 = 0 and count_neg_x5 = 12. We take the next array, which is [-1 -2 -3 -4 -5]. We check if there are any missing elements in the array. This time, however, we do not have any missing variables. We have each element, but they are negative. Regardless if any of them are positive or negative, it doesn't matter, as long as the variables are in there. Therefore l will be equal to 1. We do the exact counting as we did before and we will have: count_neg_x1 = 3, count_neg_x2 = 3, count_neg_x3 = 3, count_neg_x4 = 3 and count_neg_x5 = 11. So the final counts shall be:

count_pos_x1 = 4
count_neg_x1 = 3
count_pos_x2 = 4
count_neg_x2 = 3
count_pos_x3 = 4
count_neg_x3 = 3
count_pos_x4 = 4
count_neg_x4 = 3
count_pos_x5 = 0
count_neg_x5 = 11

Now here's what you need to do. First, you have to check if you have both the count of positive and negative instances of the same variable equal to 0. So for example, if you have the count of positive x5s equal to 0 and the count of negative x5s also equal to 0, then you'd have to stop the program and output "This formula is unsatisfiable". In our case, none of the counts meet the criteria, so we move on. Now here's the part where you have to assign a value to each variable. First, take a look at the counts and check which of the counts is equal to 0. As we can see. We have count_pos_x5 = 0, therefore x5 will have a value of 1. If it was count_neg_x5 which was equal to 0, then x5 would have been 0. Then, what you need to do is go through each array one last time and give a value to each unassigned variable. So we go through each array. We have [5], which is already defined as 1, therefore it's alright. We move on to the next array, which is [1 -2]. x1 and x2 are still undefined, therefore we take a variable, x1 and we give it a random input, either 0 or 1. Let's say that x1 randomly became 0. Now we need to check if the amount of 0s is equal to k-1, with k being the length of the array. The statement is true because we have one 0 which is x1 and k is 2, so 2-1 = 1. So 1 = 1. And we see we still have an undefined variable, which is x2. Therefore x2 must become 0 in order to fulfill the truth value, because it has a minus in front of 2. Therefore it's a negation. Next we have [-1 2]. We already defined these variables, so there's no point. Therefore we skip the array and go to [-1 -2 -3 -4 -5]. We have the undefined variables x3 and x4. We check how many 0s are in the array and check if it's equal to k-1. We have no 0s, because when negated, -1 becomes 1, -2 becomes 1 and -5 becomes 1. Therefore, we put a random value between 0 and 1 for x3. Let's say x3 is 1. We check the 0s again, they're not equal. We still have one more undefined variable, which is x4. Therefore we put another random value, let's say 1. So in the end, we'd have:

x1 -> 0
x2 -> 0
x3 -> 1 
x4 -> 1 
x5 -> 1

Write the code in Python, make sure to input the arrays from a text file and tell me the time complexity of this program.
