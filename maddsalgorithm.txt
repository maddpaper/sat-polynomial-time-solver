Alright, let's say that we have an input file with arrays. For example:
  [1 2 3 4 5]
  [-1 -2 -3 -4 -5]
  [1 -2]
  [3 -4 5]
  [5]
  [-1 2]
  [1 -1 2]
  [1 3]
  [1 4]

First, find the highest element in all the arrays and put it in an integer called "n". So for our example, we see that the highest number is 5, therefore we put n = 5.
Now, here's the actual part that you need to do. Think of the numbers in the arrays as variables. 1 represents x1, 2 represents x2, 3 represents x3 and so on. You need to assign values of 0 or 1, or {0,1} to each variable based on certain conditions. Do these steps:
First, for each variable, there's a count of their positive and negative instances. So you have a count of the positive instances of x1, like count_pos_x1, a count of the negative instances of x1, like count_neg_x1, a count of the positive instances of x2, like count_pos_x2, a count of negative instances of x2 like count_neg_x2 and so on. The positivity and negativity count is determined when you check if the element you're currently on is either positive or negative. For example, if 1 is positive, then the count of positive x1s will be affected. If it's negative, the count of negative x1s will be affected. Now, each count for their variable, both positive and negative, starts with 0. So, we would have count_pos_x1 = 0, count_neg_x1 = 0, count_pos_x2 = 0, count_neg_x2 = 0 and so on:

Now, here's the real algorithm that you need to do. What I want you to do is I want to base this algorithm on the inclusion-exclusion principle but for the counts. The way the inclusion-exclusion principle works is like this. Say you have a set A and B, and you need to do a union between them. The way it works is like this:

|A ∪ B| = |A| + |B| - |A ∩ B|.

Where |A| means the cardinality of the set, which for our case, the cardinality is represented by our variable counts. In our input, we have 7 arrays. The way we would calculate is like this. Let's take the sample array from above. We're gonna start with [1 2 3 4 5]. This is the first part that we want to do. First, we're gonna eliminate any arrays that have all the elements common in-between them. I'll show you what I mean by this but do this in the fastest way possible. So we have [1 2 3 4 5] and [5]. All the elements between the arrays are common between each other, because 5 is included in [1 2 3 4 5], therefore [1 2 3 4 5] must be eliminated. [5] does not get eliminated because  it's the smaller array. We always eliminate the bigger array between each other. We can find many that satisfy this behavior, like [1 2 3 4 5] and [1 3] are the same, or [1 2 3 4 5] and [1 4]. They fit the same condition, but you always eliminate the bigger array. Next we have [-1 -2 -3 -4 -5], but we can't find any arrays that have the elements common with each other. We have [-1 2], one element is common between them but not all of them are in common between them. If it were [-1 -2 -3 -4 -5] and [-5], or [-1 -2 -3 -4 -5] and [-1 -2] or [-1 -2 -3 -4 -5] and [-1 -3] for example, the elimination process would go and you would always delete the bigger array, which is [-1 -2 -3 -4 -5], but that isn't happening in our case so we move on. We do this for every array in part. Here's something of note. If you find dupe arrays, such as [1 2] and [2 1], you eliminate one of them, so you will have [1 2] instead. Or, if you find something like [1 -1 2], you eliminate the entire array because you have both the negative and positive value of the same integer, which is 1 and -1, and we are not allowed to do that, therefore you delete the entire array. If you have for example the array [1 1 2], you dedupe it to [1 2]. With that said, if you did the steps from before, we should now have the arrays:

[-1 -2 -3 -4 -5]
[1 -2]
[5]
[-1 2]
[1 3]
[1 4]

Now, here comes the second part which you need to do. This is the counting part. We need to iterate through the entire series of arrays and do this. First we have [-1 -2 -3 -4 -5]. We check each element in part and we need to count the variables accordingly. First we have -1. We check if it's positive or negative, we see it's negative, therefore we take the count of negative x1s and equalize it with 2^(n-k), with k being the length of the current array, so 2^(5-5) = 2^0 = 1. Therefore count_neg_x1 will be equal to 1. We do this for every single element and equalize it with 2^(n-k). For this array, we'll have count_neg_x1, count_neg_x2, count_neg_x3, count_neg_x4 and count_neg_x5 will be equal to 1. These counts only pertain to this array. We check to see if there are any previous arrays before [-1 -2 -3 -4 -5]. There are no previous arrays, therefore the counts will go global. So the global counts will be count_neg_x1, count_neg_x2, count_neg_x3, count_neg_x4, count_neg_x5 all equal to 1 while the rest of the global counts are still equal to 0. We move on to the next array, which is [1 -2]. We check each element in part. We have 1, we see it's positive, therefore we take the count of positive x1s and equalize it with 2^(n-k), with k in this case being 2. So 2^(5-2) = 2^3 = 8. We check -2, we see it's negative, therefore we take the count of negative x2s and equalize it with 2^(n-k), which is also 8. Now, we see that we have missing elements for this array, which are 3, 4 and 5. For the missing elements, we take the count of both positive and negative value for each variable and equalize it 2^(n-k-1), so 2^(5-2-1) = 2^2 = 4. So count_pos_x3, count_neg_x3, count_pos_x4, count_neg_x4, count_pos_x5 and count_neg_x5 will all be equal to 4 for this array. Now, we check if there are any previous arrays. We have the array [-1 -2 -3 -4 -5] which is previous. We verify the elements between them. We see however that between [-1 -2 -3 -4 -5] and [1 -2], we have 1 and 2 that are common BUT they differ in that one is positive and one is negative. What I mean by that is we have 1 and -1. -2 and -2 are the only elements truly common but 1 and -1 are not really common. They are common in the variable but one is positive and one is negative, therefore no special operation happens and we just add the counts globally and perform addition as well. When we add the counts together, we have count_pos_x1 = 8, count_neg_x1 = 1 count_pos_x2 = 0, count_neg_x2 = 8, count_pos_x3 = 4, count_neg_x3 = 4, count_pos_x4 = 4, count_neg_x4 = 4, count_pos_x5 = 4, count_neg_x5 = 4. We go to the next array, which is [5]. We check 5, we see it's positive, therefore the count of positive x5s will be 2^(n-k), with k being with in this case, so 2^(5-1) = 2^4 = 16. We check if there are missing elements in the array. There are, which are 1, 2, 3 and 4, therefore equalize each positive and negative count for each variable to 2^(n-k-1), so 2^(5-1-1) = 2^3 = 8, so count_pos_x1, count_pos_x2, count_pos_x3, count_pos_x4, count_neg_x1, count_neg_x2, count_neg_x3, count_neg_x4 are all equal to 8. Now, we check the previous arrays and see if it can be included or combined in any way. We have [5] with [-1 -2 -3 -4 -5], but these arrays do not match because we have 5 and -5. The element 5 exists between each array but both are positive and negative. Therefore no combination gets performed. We check instead with [1 -2]. This time however, we can perform an intersection, because [5] is missing from [1 -2]. You can perform an intersection between them if you have all the elements common in between them or if they are missing from them. I'll show what I mean with the next arrays but for now, we can do an intersection with [5] and [1 -2]. The way the intersection works is based on the inclusion-exclusion principle that I talked to you about earlier. First, we take the counts from [5] and [1 -2] and we add them together. You are adding with the global counts. So we will have count_pos_x1 = 16, count_neg_x1 = 9, count_pos_x2 = 8, count_neg_x2 = 16, count_pos_x3 = 12, count_neg_x3 = 12, count_pos_x4 = 12, count_neg_x4 = 12, count_pos_x5 = 20, count_neg_x5 = 4. Now that you added them together, you have to perform a subtraction with the intersection between [1 -2] and [5]. The way this intersection works is first, you create a temporary array with the elements [1 -2 5] in them. This gets deleted afterwards, this is only for counting the elements in the intersection. We do the same thing as we did before for this array. We equalize every count with 2^(n-k), which is 2^(5-3) = 2^2 = 4. count_pos_x1 = 4, count_neg_x2, = 4, count_pos_x5 = 4. For the missing elements, 3 and 4, we equalize the negative and positive count with 2^(n-k-1), which will be 2, so count_pos_x3, count_neg_x3, count_pos_x4, count_neg_x4 will be equal to 2. NOW, with this temporary array count, we perform the subtraction with the global counts. So we will have count_pos_x1 = 12, count_neg_x1 = 9, count_pos_x2 = 8, count_neg_x2 = 12, count_pos_x3 = 8, count_neg_x3 = 8, count_pos_x4 = 8, count_neg_x4 = 8, count_pos_x5 = 16, count_neg_x5 = 4. The inclusion-exclusion principle has been performed and therefore we move on to the next array, which is [-1 2].

Now here's what you need to do. First, you have to check if you have both the count of positive and negative instances of the same variable are equal to 2^(n-1), which is 2^(5-1) = 2^4 = 16. So for example, if you have the count of positive x5s equal to 16 and the count of negative x5s also equal to 16, then you'd have to stop the program and output "This formula is unsatisfiable". In our case, none of the counts meet the criteria, so we move on. Now here's the part where you have to assign a value to each variable. First, take a look at the counts and check which of the counts is equal to 0. As we can see. We have count_pos_x5 = 0, therefore x5 will have a value of 1. If it was count_neg_x5 which was equal to 0, then x5 would have been 0. Then, what you need to do is go through each array one last time and give a value to each unassigned variable. So we go through each array. We have [5], which is already defined as 1, therefore it's alright. We move on to the next array, which is [1 -2]. x1 and x2 are still undefined, therefore we take a variable, x1 and we give it a random input, either 0 or 1. Let's say that x1 randomly became 0. Now we need to check if the amount of 0s is equal to k-1, with k being the length of the array. The statement is true because we have one 0 which is x1 and k is 2, so 2-1 = 1. So 1 = 1. And we see we still have an undefined variable, which is x2. Therefore x2 must become 0 in order to fulfill the truth value, because it has a minus in front of 2. Therefore it's a negation. Next we have [-1 2]. We already defined these variables, so there's no point. Therefore we skip the array and go to [-1 -2 -3 -4 -5]. We have the undefined variables x3 and x4. We check how many 0s are in the array and check if it's equal to k-1. We have no 0s, because when negated, -1 becomes 1, -2 becomes 1 and -5 becomes 1. Therefore, we put a random value between 0 and 1 for x3. Let's say x3 is 1. We check the 0s again, they're not equal. We still have one more undefined variable, which is x4. Therefore we put another random value, let's say 1. So in the end, we'd output the message "This formula is satisfiable":

x1 -> 0
x2 -> 0
x3 -> 1 
x4 -> 1 
x5 -> 1

You should output the counts, both positive and negative, for each variable, regardless if the formula is satisfiable or not.

Write the code in Python, make sure to input the arrays from a text file and tell me the time complexity of this program. Make it so that you can input the arrays like 1 2 3 4 5 and not [1 2 3 4 5], like in brackets.
